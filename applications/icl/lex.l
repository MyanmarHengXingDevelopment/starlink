%{
/******************************************************************************
 *
 *	L E X . L 
 *
 * lex() source for ICL
 *
 * Created : 	Chrispen Goswell Autumn 1991
 * Edited  :	S.K.Robinson  1992
 * 		B.K.McIlwrath subsequently
 *
 * This specification of the lexical analyser for ICL is compiled by lex(1) 
 * into a C lexical analyser called yylex(). The parser generated by yacc(1) 
 * (yyparse()) calls this to receive input tokens. The longest token matching
 * the input returned but, if several patterns match then the first matching
 * token is returned. In this case, the order IS IMPORTANT!
 *
 * yylex() calls input() (to get the next input character) and unput() (to 
 * put a character back into the input stream).  These pre-defined as macros by
 * lex but we re-define them to use the functions icl_input() and icl_unput 
 * (in file input.c) which utilise the line buffer returned by the 
 * iosubsystem and request a new line when necessary.
 *
 * Due to the particular nature of the ICL language (acting as both a 
 * programmatic language and as a transparent filter to the host operating 
 * system) the lexical analysis of the input is complicated and we need to 
 * keep some recollection of what has been seen before in order to correctly 
 * analyse the next input token.
 * 
 * This is done using the "mode" facility of the lex(1) generated code.  A 
 * given lexical analyser can be in any ONE of m modes.  Initially it is 
 * understood to be in INITIAL mode but by using the BEGIN macro call we can 
 * set it to some other mode (which lex is informed about using the %start 
 * command).  Once in a mode "mode' only those patterns starting <mode>pattern
 * will be processed.
 *
 ******************************************************************************

 ******************************************************************************
 *
 *			ICL MODES
 *
 * ICL uses four lex FOUR modes to tokenize the input:
 *
 *	INITIAL when it starts the lexical analysis of a new command line. 
 *
 *	OPENS when it has seen an identifer or $(DCL) or !(SH) in INITIAL mode
 *	and is expecting either an '=' (when changes to EXP mode as the line 
 *	is of the form xxxx = expression) or the rest of a command line (of 
 *	the form xxxx yyyy zzzzz .......).
 *
 *	VSUBS mode is entered from INSTRING mode when a subscript (eg an NDF 
 *	component specification) is encountered. For example, 
 *	a_file_name(1:20). It is recognised by the opening parenthesis
 *	immediately after the name.
 *
 *	EXP mode is used to evaluate expressions. It can be entered for the
 *	duration of the current command from INITIAL mode (after seeing IF,
 *	WHILE FOR = PROC or EXCEPTION)or from OPENS mode after an "=" has been
 *	processed.
 *	However we also need to support a temporary change to this mode from 
 *	both OPENS and VSUBS modes when an open parenthesis is found. For 
 *	example from OPENS mode the command could be 
 *	'XXXX YYYY (EXPRESSION) ZZZZZ' and from VSUBS mode a file specification
 *	could be 'A_FILE((A):(B))'.
 *
 * 	We remember which mode we should return to by using the lex variables
 *	'opens_context' and 'subs_context' and we also need to keep track
 *	of parehthesis nesting by the variable 'nested.
 *
 ******************************************************************************
 *
 *			STRING VARIABLES IN ICL
 *
 * ICL is peculiar in that it has THREE types of string:
 *
 *	A 'closed' string which is a string enclosed in double quotes (") or 
 *	single quotes (').
 *
 *	An 'open' string (any sequence of characters not beginning with
 *	', ", (, SPACE, COMMA or NEWLINE.
 *
 *	An xopen-string which is helpful in tokenization and is defined as
 *	an open string which is not allowed to begin with a = symbol. This
 *	allows us to discrimiate between an assignment and a command line.
 *	(for example and lines such as I=55 would parse as the command I and 
 *	the open-string '=55' if this distinction was not made.
 *
 ******************************************************************************
 */

/******************************************************************************
 *
 * Include ICL standard header file which includes the definition of the
 * type 'value'. Also declare the external reference to the string pointer 
 * 'errormessage' which can be used by the lexical analyser to communicate
 * a suitable error text to the parser (parse.y) when input fails to parse.
 *
 ******************************************************************************
 */
#include "icl.h"
#include "input.h"
extern char *errormessage;					/* parse.c */

/******************************************************************************
 * We include the header file that YACC generates to name its terminal values
 ******************************************************************************
 */
/* Note that the autoconf system generates a header files the same name as
  the original .y files */
#include "parse.h"

/******************************************************************************
 * The variable 'nested' keeps track of the paraenthesis nesting level in 
 * parenthesised expressions and file subscripts to allow us to detect when 
 * a complete  parenthesied expression has been processed in EXP mode and
 * that the syntax is correct in VSUBS mode.
 ******************************************************************************
 */
static int nested = 0;

/******************************************************************************
 * Useful variable - used extensively in character processing
 ******************************************************************************
 */
static int ch;

/******************************************************************************
 * When in OPENS or VSUBS modes and we meet a parenthesised expression we 
 * temporarily change to EXP mode to process the expression and return to the
 * current mode on completion. Either of the variables 'opens_context' and
 * 'subs_context' may be set to allow this context change when a closing
 * parenthesis ')' is seen.
 *
 ******************************************************************************
 */
static int opens_context = 0,
	   subs_context = 0;

/******************************************************************************
 * We use the following flag to keep track of square brackets used to indicate
 * optional procedure arguments. This featre was added on May,1995 and is
 * NOT in either VMS ICL or SG/5 yet. (BKM)
 ******************************************************************************
 */
static int in_sqbkt = 0;

/*****************************************************************************
 * Redefine input() and unput() so that the ICL routines are used
 ******************************************************************************
 */
#ifdef FLEX_SCANNER
#define YY_INPUT(buf,result,max_size) \
    { \
    int c = icl_input(); \
    result = (c == 0) ? YY_NULL : (buf[0] = c, 1); \
    }
#else
#undef input
#define input()	(icl_input())
#undef unput
#define unput(foo) (icl_unput (foo))
#endif


/*****************************************************************************
 * Declarations of the support routine in the 'user subroutines' lex section
 ******************************************************************************
 */
static int parsestring(void);
static char *stredit(char * s);
static int remove_spaces(void);
static char *fixup_quotes (char *s);
static int convertintconst(void);

/******************************************************************************
 *
 * The following macros describe common kinds of tokens.
 *
 * Notes:
 *
 * 1) Both kinds of string quotes are recognised by {string}.
 *
 * 2) We distinguish xopen_strings (cannot begin with a = symbol) and
 *    open_strings (that can) as, in OPEN mode, we use the = symbol to 
 *    distingush an assignment statement from a command statement so that 
 *    open strings in this mode cannot begin with the symbol =.
 *
 * 3) {identifier} permits underscore in the tail.
 *
 * {i} is a decimal digit sequence, {d} represents a optional fractional
 * part (after a decimal point) and {e} represents the exponent part of a 
 * floating number.
 *
 ******************************************************************************
 */
%}
string				(\"([^"\n]|\"\")*\")|(\'([^\n']|\'\')*\')

open_string			[^'"(, \t\n][^ \t,\n=(]*

identifier			([A-Za-z][A-Za-z_0-9]*)

i				[0-9]+

d				[0-9]*

e				([Ee][+-]?[0-9]+)

%{
/******************************************************************************
 * Inform lex(1) of the additional modes for ICL. INITIAL mode is the lex
 * default.
 *
 * Also adjust sizes of internal lex tables.
 *
 ******************************************************************************
 */
%}
%start EXP OPENS INSTRING VSUBS
%p 1600
%n 250
%k 1700
%a 1800
%o 2100
%{
/******************************************************************************/
%}
%%
<INITIAL>[hH][iI][dD][dD][eE][nN]		{ return HIDDEN; }
<INITIAL>[eE][nN][dD]		 		{ return END; }
<INITIAL>[eE][lL][sS][eE]	 		{ return ELSE; }
<INITIAL>[eE][lL][sS][eE][iI][fF]		{ return ELSEIF; }
<INITIAL>[eE][nN][dD][pP][rR][oO][cC]		{ return ENDPROC; }
<INITIAL>[eE][nN][dD][lL][oO][oO][pP]		{ return ENDLOOP; }
<INITIAL>[eE][nN][dD][iI][fF]			{ return ENDIF; }
<INITIAL>[eE][nN][dD][eE][xX][cC][eE][pP][tT][iI][oO][nN] { 
							return ENDEXCEPTION;
						}
<INITIAL>[bB][rR][eE][aA][kK]			{ return BREAK; }
<INITIAL>[lL][oO][oO][pP]			{ return LOOP; }
<INITIAL>[pP][rR][oO][cC]			{ BEGIN EXP; return PROC; }
<INITIAL>[iI][fF]				{ BEGIN EXP; return IF; }
<INITIAL>[wW][hH][iI][lL][eE]			{ BEGIN EXP; return WHILE; }
<INITIAL>[fF][oO][rR]				{ BEGIN EXP; return FOR; }
<INITIAL>[eE][xX][cC][eE][pP][tT][iI][oO][nN]	{ BEGIN EXP; return EXCEPTION; }
<INITIAL>{identifier}				{ ch = remove_spaces();
						  if( ch != '=')
						     BEGIN OPENS;
						  yylval.ptr = (char *) yytext;
						  return NAME; }
<INITIAL>"%"					{ return IMMEDIATE; }
<INITIAL>"#"					{ return BUILTIN; }
<INITIAL>[$!][ \t]*		{ yylval.ptr = "SH";  BEGIN OPENS; return NAME; }
<INITIAL>"="					{ BEGIN EXP; return EQUAL; }
<INITIAL>[;{][^\n]*	{ yylval.ptr = (char *) yytext;
			  opens_context = nested = 0; return COMMENT; }
<INITIAL>{string}	{ yylval.ptr = fixup_quotes ((char *) yytext);
			  return STRING; }

<OPENS>"("		{ BEGIN EXP; nested++; opens_context = 1; 
			  return OPEN_PAREN; }
<OPENS>{string}		{ yylval.ptr = fixup_quotes ((char *) yytext);
			  return STRING; }
<OPENS>{identifier}[\t ]*= { yylval.ptr = stredit((char *)yytext);
			  ch = remove_spaces();
                          if( !strchr("('\"", ch))
			      BEGIN INSTRING;
			  return OPENSTRING; }
<OPENS>{open_string}	{ return parsestring(); }
<OPENS>","	       	{ return COMMA; }
<OPENS>[ \t]*		{ ch = input();
			  unput(ch);
			  if( ch != '\n')
			      return SPACE;
			}

<INSTRING>[^ \t,\n=()]*	{ return parsestring(); }
<INSTRING>")"		{ return ERROR; }
<INSTRING>","	       	{ BEGIN OPENS; return COMMA; }
<INSTRING>[ \t]*	{ BEGIN OPENS; return SPACE; }

<VSUBS>[^() \t\n]* 	{   yylval.ptr = (char *) yytext;
			  return OPENSTRING; }
<VSUBS>"("		{ BEGIN EXP; nested++;
			  return OPEN_PAREN; }
<VSUBS>")"		{ BEGIN INSTRING; subs_context = 0;
			  yylval.ptr = (char *) yytext;
			  if( --nested == 0)
			      return CLOSE_PAREN;
			  else
			      return ERROR;
			}
<VSUBS>" "		{ return ERROR; }

<EXP>[;{][^\n]*		{ yylval.ptr = (char *) yytext; 
			  opens_context = subs_context = nested = 0;
			  return COMMENT; }
<EXP>","		{ return COMMA; }
<EXP>"("		{ ++nested; return OPEN_PAREN; }
<EXP>")"		{
			if( opens_context && nested == 1 ) {
			    opens_context = 0;
			    BEGIN OPENS;
			} else if( subs_context && nested == 2 )
			    BEGIN VSUBS;
			--nested;
			return CLOSE_PAREN;
			}
<EXP>"**"					{ return POWER; }
<EXP>"*"					{ return MULTIPLY; }
<EXP>"/"					{ return DIVIDE; }
<EXP>"+"					{ return ADD; }
<EXP>"-"					{ return SUBTRACT; }
<EXP>"<"					{ return LESS_THAN; }
<EXP>"<="					{ return LESS_EQUAL; }
<EXP>">"					{ return GREATER_THAN; }
<EXP>">="					{ return GREATER_EQUAL; }
<EXP>"<>"					{ return NOT_EQUAL; }
<EXP>":"					{ return FORMAT; }
<EXP>"&"					{ return CONCAT; }
<EXP>"="					{ return EQUAL; }
<EXP>"["					{ if (in_sqbkt == 1)
						     return ERROR;
						  else {
						     in_sqbkt = 1;
						     return OPEN_SQBKT;
						  }
						}
<EXP>"]"					{ if (in_sqbkt != 1)
						     return ERROR;
						}

<EXP>[tT][rR][uU][eE]				{ return ICL_TRUE; }
<EXP>[fF][aA][lL][sS][eE]			{ return ICL_FALSE; }
<EXP>[aA][nN][dD]				{ return AND; }
<EXP>[oO][rR]					{ return OR; }
<EXP>[nN][oO][tT]				{ return NOT; }
<EXP>[tT][oO]					{ return TO; }
<EXP>[sS][tT][eE][pP]				{ return STEP; }
<EXP>{identifier}		{ yylval.ptr = (char *) yytext; return NAME; }
<EXP>{string}			{ yylval.ptr = fixup_quotes ((char *) yytext); 
				  return STRING; }

<EXP>({d}\.{i}{e}?|{i}(\.{d})?{e}|{i}\.{d}{e}?)	{ /* floating point constants */
					(void) sscanf( (char *)yytext, 
					   	      "%lf", &yylval.real);
			 		if(!isfinite(yylval.real))
			   		{
			   		 errormessage = "real number too large";
			   		 return ERROR;
			   		}
			 		else
			   		 return REAL;
				}
<EXP>{i}			{ /* decimal constants */
				  return convertintconst(); }
<EXP>%[xX][0-9A-Fa-f]+		{ /* hexadecimal constants */ 
				  return convertintconst(); }
<EXP>%[oO][0-7]+		{ /* octal constants */
				  return convertintconst(); }
<EXP>%[bB][01]+	        	{ /* binary constants */
				  return convertintconst(); }
[\t ]			{;}
[\t ]?\n		{
			if (in_sqbkt != 0) {
			    in_sqbkt = 0;
			    unput('\n');
			    return CLOSE_SQBKT;
			}			
			    opens_context = subs_context = nested = 0;
			    BEGIN INITIAL;
			    return NEWLINE;
			}
['"]			{ return QUOTE; }
.			{ return BADCHAR; }
%%
/******************************************************************************
 *
 * Parsing ICL command parameters is tricky as they may include HDS/NDF 
 * components and subscripts. For example:

 *	test a=hdsfile.array(3).data(1:2,4:5)
 *
 * where the command "test" takes an NDF specification including both array 
 * and data section subscripts.
 *
 * Further we wish to allow the subscripts to refer to ICL variables and
 * expressions as in:
 *
 *	test a=hdsfile.array((a)).data((b):(c),(d):(e))
 *
 * where a,b,c,d,e are ICL variables
 *
 * To aid the parsing we use the lex parse states and the function below.
 * Note - this function is not strictly necessary but attempting the parse in
 * pure lex breaks on many systems!
 *
 ******************************************************************************
 */
static
int parsestring(void)
{
    if( (ch=input()) != '(') {
	unput(ch);
	yylval.ptr = (char *) yytext;
	return OPENSTRING;
    } else {
	yytext[yyleng++] = ch;
	yytext[yyleng] = '\0';
	nested++;
	for(;;)
	    switch(ch = input()){
	      case '\n':
	      case ' ':
	      case '\t':
		yytext[0] = '\0';
		unput(ch);
		return ERROR;
	      case '(':
		unput(ch);
		yylval.ptr = (char *) yytext;
		BEGIN VSUBS; subs_context = 1;
		return QUALSTRING;
	      case ')':
		yytext[yyleng++] = ch;
		yytext[yyleng] = '\0';
		yylval.ptr = (char *) yytext;
		if( --nested == 0)
		    return OPENSTRING;
		else
		    return ERROR;
	      default:
		yytext[yyleng++] = ch;
		yytext[yyleng] = '\0';
	    } /* switch */
    } /* if */
}

/******************************************************************************
 *
 *		S T R E D I T (char *s)
 *
 * This function eliminates spaces and tabs (and, in fact, ALL non-printing
 * characters) from the string 's'. As the resulting string must have a length
 * less than or equal to the input string this function works in-place and
 * requires no additional storage.
 *
 ******************************************************************************
 */
static
char *stredit(char *s)
{
    char *t=s, *t1;
    while(*t != '\0') {
	if(*t > ' ')
	    t++;
	else {
	    t1 = t+1;
	    while(*t1 != '\0' &&
		  *t1 <= ' ')
		t1++;
	    if( *t1 != '\0')
		strcpy(t, t1);
	    else
		*t = '\0';
	}
    }
    return s;
}
	
/******************************************************************************
 * As a double quoted strings in ICL may contain single quotes and vice-versa
 * we cannot simply make all strings have the same quoting.  We therefore 
 * remove the outer quotes (" or ') and scan the string removing any double 
 * quotes corresponding to the quoting quotes (ie we remove "" from "...." and
 *  any '' from '.....').
 *
 * lex returns the remaining string without the quoting quotes to ICL.
 *
 * This means that when listing a procedure with strings in it we scan the 
 * string given and use the quotes that are not used within the string.  If 
 * both are used we print the string using double quotes and double any 
 * contained double quotes (function restore_iclstring() in utils.c).
 *
 ******************************************************************************
 */
static 
char *fixup_quotes (char *s)
{
    char *p=s+1, *q=s, ch=*s;		/* start just after the first quote, 
					 * set ch to that quote */

    s[strlen(s) - 1] = '\0';		/* remove last quote */
    while (*p != '\0') {
	if (*p == ch)			/* if we find occurence of quoting
					 * quote symbol skip one */
	++p;
	*q++ = *p++;
    }
    *q++ = '\0';			/* terminate resulting unquoted 
					 * string */
    return s;
}

/******************************************************************************
 *
 * Skip spaces and tab characters and return the next character found.
 * Note that the character returned is also unput() back into the input stream
 * so it it available to be parsed next.
 *
 ******************************************************************************
 */
static
int remove_spaces(void)
{
    ch=input();
    while( ch == ' ' ||
	   ch == '\t')
	ch = input();
    unput(ch);		/* Return character AFTER blank to input stream */
    return ch;		/* and to caller */
}

/******************************************************************************
 *
 * We wish lex to parse based constants (eg B00010) convert them to deciomal
 * and make them available to yyparse() in yylval.integer.  The following 
 * routine calls basedstringtointvalue() (carith.c) to perform this
 * conversion.  If an exception is returned we pass the exception string back
 * to yyparse() via errormessage and return the token type ERROR, otherwise we
 * assign the integer value to yylval.integer using integer_part() (value.c).
 *
 ******************************************************************************
 */
static
int convertintconst(void)
{
    extern value basedstringtointvalue(char *str);		/* carith.c */
    extern int integer_part(value val);				/* value.c */
    static value val;

    if(isexc(val = basedstringtointvalue((char *) yytext))) {
	errormessage = string_part(val);
	return ERROR;
    } else {
	yylval.integer = integer_part(val);
	return(INTEGER);
    }
}
